<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mini DuckDuckGo Browser</title>

  <!-- PWA / iOS -->
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="DuckMini">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">

  <style>
    :root{--bg:#f7f7f8; --accent:#1a73e8}
    html,body{height:100%;margin:0;font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;}
    header{display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg);box-shadow:0 1px 0 rgba(0,0,0,.06)}
    button{border:0;background:transparent;padding:6px;border-radius:6px}
    .btn{cursor:pointer}
    input[type="search"]{flex:1;padding:8px 10px;border-radius:10px;border:1px solid #ddd;font-size:16px}
    .controls{display:flex;gap:6px;width:100%;align-items:center}
    #frameWrap{position:fixed;left:0;right:0;bottom:0;top:56px;background:white}
    iframe{width:100%;height:100%;border:0;background:white}
    .settings{padding:10px;background:#fff;border-top:1px solid #eee;display:flex;gap:8px;align-items:center;}
    label{font-size:13px}
    small.gray{color:#666;font-size:12px}
  </style>
</head>
<body>
  <header>
    <button id="back" title="Zur√ºck" class="btn">‚óÄ</button>
    <button id="forward" title="Vor" class="btn">‚ñ∂</button>

    <div class="controls" style="flex:1">
      <input id="q" type="search" placeholder="DuckDuckGo durchsuchen‚Ä¶" autocomplete="off" autocapitalize="off" autocorrect="off" />
      <button id="searchBtn" class="btn" title="Suchen">üîç</button>
    </div>

    <button id="settingsBtn" class="btn" title="Einstellungen">‚öôÔ∏è</button>
  </header>

  <div id="frameWrap">
    <iframe id="pane" srcdoc="<p style='font-family:system-ui;padding:20px'>Starte eine Suche oben‚Ä¶</p>"></iframe>
  </div>

  <div id="settingsPanel" class="settings" style="display:none">
    <label><input id="enabled" type="checkbox" checked> Tipp-Simulation</label>
    <label style="display:flex;gap:6px;align-items:center">
      <span class="gray">Pause (ms)</span>
      <input id="startDelay" type="number" min="0" value="450" style="width:80px">
    </label>
    <label style="display:flex;gap:6px;align-items:center">
      <span class="gray">Min (ms)</span>
      <input id="minInterval" type="number" min="5" value="25" style="width:70px">
    </label>
    <label style="display:flex;gap:6px;align-items:center">
      <span class="gray">Max (ms)</span>
      <input id="maxInterval" type="number" min="5" value="160" style="width:70px">
    </label>
    <small class="gray" style="margin-left:auto">DuckDuckGo wird im Frame geladen, falls erlaubt.</small>
  </div>

  <script>
  // --- Einstellungen / Defaults ---
  const prefs = {
    enabled: true,
    startDelay: 450,
    minInterval: 25,
    maxInterval: 160
  };

  // --- DOM ---
  const q = document.getElementById('q');
  const searchBtn = document.getElementById('searchBtn');
  const pane = document.getElementById('pane');
  const back = document.getElementById('back');
  const forward = document.getElementById('forward');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settingsPanel');
  const enabledEl = document.getElementById('enabled');
  const startDelayEl = document.getElementById('startDelay');
  const minIntervalEl = document.getElementById('minInterval');
  const maxIntervalEl = document.getElementById('maxInterval');

  // load saved prefs from localStorage if any
  try {
    const saved = JSON.parse(localStorage.getItem('duckmini_prefs')||'{}');
    Object.assign(prefs, saved);
  } catch(e){}

  // apply prefs to controls
  enabledEl.checked = prefs.enabled;
  startDelayEl.value = prefs.startDelay;
  minIntervalEl.value = prefs.minInterval;
  maxIntervalEl.value = prefs.maxInterval;

  // save when changed
  [enabledEl,startDelayEl,minIntervalEl,maxIntervalEl].forEach(el=>{
    el.addEventListener('change',()=>{
      prefs.enabled = !!enabledEl.checked;
      prefs.startDelay = Math.max(0, Number(startDelayEl.value)||0);
      prefs.minInterval = Math.max(1, Number(minIntervalEl.value)||5);
      prefs.maxInterval = Math.max(1, Number(maxIntervalEl.value)||1000);
      if (prefs.minInterval>prefs.maxInterval) { prefs.minInterval = prefs.maxInterval; minIntervalEl.value = prefs.minInterval; }
      localStorage.setItem('duckmini_prefs', JSON.stringify(prefs));
    });
  });

  // toggle settings panel
  settingsBtn.addEventListener('click', ()=> settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'flex' : 'none');

  // Navigation controls (basic: communicate with iframe via history limited handling)
  back.addEventListener('click', ()=> {
    // try to go back in iframe; if not possible, do top history
    try { pane.contentWindow.history.back(); } catch(e){ history.back(); }
  });
  forward.addEventListener('click', ()=> {
    try { pane.contentWindow.history.forward(); } catch(e){ history.forward(); }
  });

  // Build DuckDuckGo search URL
  function ddgUrl(query) {
    const qenc = encodeURIComponent(query || '');
    return 'https://duckduckgo.com/?q=' + qenc + '&t=hm'; // t param optional
  }

  // Try to load URL in iframe, fallback to top.open if embed blocked (timeout)
  function loadInPane(url) {
    let loaded = false;
    pane.src = url;
    const to = setTimeout(()=> {
      if (!loaded) {
        // fallback: open in same tab (replace) for better experience on mobile
        window.location.href = url;
      }
    }, 1800); // if no load event in 1.8s assume blocked -> fallback

    pane.onload = () => {
      loaded = true;
      clearTimeout(to);
    };
    // also catch explicit error by listening to message? limited for cross-origin
  }

  // Search action
  function doSearch(query){
    if (!query) return;
    const url = ddgUrl(query);
    loadInPane(url);
  }

  searchBtn.addEventListener('click', ()=> doSearch(q.value));
  q.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      e.preventDefault();
      doSearch(q.value);
    }
  });

  // --- Typing simulation logic for the search input field ---
  (function typingSim(){
    let timer = null;
    let lastText = '';
    const timers = { };

    function dispatchInputEvent(el){
      const ev = new Event('input', { bubbles: true, cancelable: true });
      el.dispatchEvent(ev);
    }

    async function simulateTyping(target, finalText){
      if (!prefs.enabled) return;
      // simple visual: clear and retype
      target.focus();
      // save selection
      let selStart = target.selectionStart, selEnd = target.selectionEnd;
      target.value = '';
      dispatchInputEvent(target);

      for (let i=0;i<finalText.length;i++){
        const ch = finalText[i];
        // append char
        const prev = target.value || '';
        target.value = prev + ch;
        try { target.selectionStart = target.selectionEnd = target.value.length; } catch(e){}
        dispatchInputEvent(target);

        // random delay
        const delay = prefs.minInterval + Math.random()*(prefs.maxInterval - prefs.minInterval || 0);
        await new Promise(r=>setTimeout(r, Math.max(1, delay|0)));
      }

      // restore caret roughly at end
      try { target.selectionStart = selStart; target.selectionEnd = selEnd; } catch(e){}
      dispatchInputEvent(target);
    }

    function scheduleSim(el, text){
      if (!prefs.enabled) return;
      // clear any running timer
      if (timers[el]) clearTimeout(timers[el]);
      timers[el] = setTimeout(()=>{
        simulateTyping(el, text).catch(console.error);
        delete timers[el];
      }, prefs.startDelay);
    }

    // input listener on our own search input
    q.addEventListener('input', (e)=>{
      if (!prefs.enabled) return;
      const text = q.value;
      // if user is actively typing, wait for pause
      scheduleSim(q, text);
    });

    // handle paste
    q.addEventListener('paste', (e)=>{
      // after paste, schedule simulation
      setTimeout(()=> scheduleSim(q, q.value), 50);
    });

  })();

  // Register service worker for caching (optional)
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').catch(()=>{/*sw optional*/});
  }

  </script>
</body>
</html>
